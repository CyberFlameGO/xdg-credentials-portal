// This code was autogenerated with `dbus-codegen-rust `, see https://github.com/diwic/dbus-rs

use dbus;
use dbus::arg;
use dbus::tree;

pub trait U2FPortalIface {
    fn register(
        &self,
        app_id: &str,
        challenge: Vec<u8>,
        registered_keys: Vec<::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>>,
        timeout_seconds: u32,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;

    fn sign(
        &self,
        app_id: &str,
        challenge: Vec<u8>,
        registered_keys: Vec<::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>>,
        timeout_seconds: u32,
    ) -> Result<dbus::Path<'static>, tree::MethodErr>;
}

pub fn u2f_portal_server_tree<F, T, D>(
    factory: &tree::Factory<tree::MTFn<D>, D>,
    data: D::Interface,
    f: F,
) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: U2FPortalIface,
    F: 'static + for<'z> Fn(&'z tree::MethodInfo<tree::MTFn<D>, D>) -> &'z T,
{
    let i = factory.interface("org.freedesktop.portal.U2F", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let app_id: &str = i.read()?;
        let challenge: Vec<u8> = i.read()?;
        let registered_keys: Vec<
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        > = i.read()?;
        let timeout_seconds: u32 = i.read()?;
        let d = fclone(minfo);
        let handle = d.register(app_id, challenge, registered_keys, timeout_seconds)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(handle);
        Ok(vec![rm])
    };
    let m = factory.method("Register", Default::default(), h);
    let m = m.in_arg(("appId", "s"));
    let m = m.in_arg(("challenge", "ay"));
    let m = m.in_arg(("registeredKeys", "aa{sv}"));
    let m = m.in_arg(("timeoutSeconds", "u"));
    let m = m.out_arg(("handle", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let app_id: &str = i.read()?;
        let challenge: Vec<u8> = i.read()?;
        let registered_keys: Vec<
            ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>,
        > = i.read()?;
        let timeout_seconds: u32 = i.read()?;
        let d = fclone(minfo);
        let handle = d.sign(app_id, challenge, registered_keys, timeout_seconds)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(handle);
        Ok(vec![rm])
    };
    let m = factory.method("Sign", Default::default(), h);
    let m = m.in_arg(("appId", "s"));
    let m = m.in_arg(("challenge", "ay"));
    let m = m.in_arg(("registeredKeys", "aa{sv}"));
    let m = m.in_arg(("timeoutSeconds", "u"));
    let m = m.out_arg(("handle", "o"));
    let i = i.add_m(m);
    i
}
